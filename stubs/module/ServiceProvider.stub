<?php

declare(strict_types=1);

namespace App\Modules\{{module}}\Infrastructure\Providers;

use App\Modules\{{module}}\Infrastructure\Models\{{module}};
use App\Modules\{{module}}\Infrastructure\Repositories\{{module}}Repository;
use App\Modules\{{module}}\Infrastructure\Repositories\{{module}}RepositoryInterface;
use Illuminate\Filesystem\Filesystem;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\Facades\Gate;
use Illuminate\Support\Facades\Route;
use Illuminate\Support\ServiceProvider;

class {{module}}ModuleServiceProvider extends ServiceProvider
{
    /**
     * Register module-specific bindings (repositories, services, etc.)
     * This is module-specific and should be in individual service providers.
     */
    public function register(): void
    {
        $this->app->bind({{module}}RepositoryInterface::class, {{module}}Repository::class);
    }

    /**
     * Bootstrap module-specific resources (routes, policies, observers, events)
     * This is module-specific and should be in individual service providers.
     * ModularServiceProvider handles only global resources (migrations, factories, helpers).
     */
    public function boot(): void
    {
        // Check if module is enabled before loading
        if (! $this->isModuleEnabled()) {
            return;
        }

        $this->registerPolicies();
        $this->registerObservers();
        $this->registerEvents();
        $this->loadRoutes();
    }

    /**
     * Check if this module is enabled in config/modules.php
     */
    protected function isModuleEnabled(): bool
    {
        return (bool) config("modules.specific.{{module}}.enabled", true);
    }

    /**
     * Load module routes.
     * Each module is responsible for loading its own routes.
     * Routes already have prefix and middleware defined in route files.
     */
    protected function loadRoutes(): void
    {
        $routeFile = __DIR__.'/../Routes/{{module_lower}}.php';

        if (! file_exists($routeFile)) {
            return;
        }

        // Routes already have prefix and middleware in route files, just require them
        require $routeFile;
    }

    /**
     * Register module policies.
     * Each module is responsible for registering its own policies.
     */
    protected function registerPolicies(): void
    {
        $policyClass = "App\\Modules\\{{module}}\\Infrastructure\\Policies\\{{module}}Policy";

        if (class_exists($policyClass) && class_exists({{module}}::class)) {
            Gate::policy({{module}}::class, $policyClass);
        }
    }

    /**
     * Register module observers.
     * Each module is responsible for registering its own observers.
     */
    protected function registerObservers(): void
    {
        $observerClass = "App\\Modules\\{{module}}\\Infrastructure\\Observers\\{{module}}Observer";

        if (class_exists($observerClass) && class_exists({{module}}::class)) {
            {{module}}::observe($observerClass);
        }
    }

    /**
     * Register module events and listeners.
     * Each module is responsible for registering its own events.
     */
    protected function registerEvents(): void
    {
        $basePath = app_path("Modules/{{module}}");
        $eventsPath = "{$basePath}/Application/Events";
        $listenersPath = "{$basePath}/Application/Listeners";

        if (! is_dir($eventsPath) || ! is_dir($listenersPath)) {
            return;
        }

        $fs = new Filesystem();

        foreach ($fs->files($eventsPath) as $eventFile) {
            $eventName = $eventFile->getFilenameWithoutExtension();
            $eventClass = "App\\Modules\\{{module}}\\Application\\Events\\{$eventName}";

            if (! class_exists($eventClass)) {
                continue;
            }

            $listenerName = $eventName.'Listener';
            $listenerClass = "App\\Modules\\{{module}}\\Application\\Listeners\\{$listenerName}";

            if (class_exists($listenerClass)) {
                Event::listen($eventClass, $listenerClass);
            }
        }
    }
}

